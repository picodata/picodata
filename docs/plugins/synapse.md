# Synapse

В данном разделе приведены сведения о
[Synapse](https://git.picodata.io/picodata/synapse), плагине для
СУБД Picodata.

## Общие сведения {: #intro }

Основная задача Synapse ("Синапса") — предоставить пользователям
инструмент миграции с кластера проприетарной СУБД Oracle (например,
Oracle Exadata) на кластер PostgreSQL, использующий открытое (open
source) программное обеспечение.

Synapse позволяет переносить данные из одного кластера в другой
без их остановки. Для этого в плагине реализованы следующие
модули:

- начальный перенос данных
- перенос и синхронизация изменений (Change Data Capture, CDC)

Оба модуля могут работать параллельно. Консистентное состояние целевого
кластера PostgreSQL будет достигнуто не ранее чем отработает модуль
начального переноса данных.

## Схема переноса {: #migration }

Перенос данных из Oracle в PostgreSQL происходит при помощи
посредничества Picodata и Synapse. Кластер Picodata с плагином
Synapse выступает в роли промежуточного звена, транслируя через себя
данные из Oracle в PostgreSQL. Схема переноса данных показана ниже.

![SYNAPSE GENERAL SCHEME](../images/synapse_general.svg)

Для переноса данных требуется выполнить следующие условия:

- на стороне Oracle предварительно нужно настроить внешний
[XStream](https://docs.oracle.com/en/database/oracle/oracle-database/19/xstrm/introduction-to-xstream.html#GUID-644C0567-E409-4611-9D9E-C5C51FBF2DE0)
(XStream Out) — API-интерфейс для взаимодействия с внешними системами.
Это специальный механизм Oracle, с помощью которого можно получать
события об изменении состояния данных в порядке очереди
- на стороне PostgreSQL создать таблицы, в которые требуется перенести
  данные из Oracle. Они не обязательно должны повторять схему в Oracle
- подготовить [YAML-файл конфигурации](#configuration) для Synapse с
  настройками подключения и шардирования целевых таблиц и
  [сопоставлением](#mapping) структуры данных Oracle в структуру данных
  Postgres

## Подробности реализации {: #detailed_design }

Каждый экземпляр Synapse может работать только с одним подключением по Xstream
и транслировать данные только в один кластер PostgreSQL. С помощью Xstream можно
перенести таблицу или несколько таблиц, причем как с активного инстанса Oracle,
так и с его реплики.

На принимающем кластере PostgreSQL должны быть заранее созданы таблицы с
совместимым набором колонок (число колонок и тип их данных должны
подходить к исходным таблицам). Если кластер PostgreSQL шардирован, то
Synapse должен знать ключ распределения для каждой из таблиц. Если
требуется трансляция данных в несколько кластеров PostgreSQL, то
потребуется соответственное количество инстансов Picodata с плагином
Synapse. Это отражено на схеме ниже.

![SYNAPSE DETAILED SCHEME](../images/synapse_detailed.svg)

Все полученные из Oracle данные записываются в кластер PostgreSQL в
виде отдельных транзакций. Фактом записи в целевой кластер является
получение соответствующего сообщения `COMMIT` от кластера Oracle.

При сбое соединения активные транзакции откатываются; в дальнейшем они
повторяются заново без нарушения консистентности и потери данных
(благодаря идемпотентности DML-операций, которые Synapse использует для
сохранения данных в Postgres).

Synapse разумно потребляет вычислительные и сетевые ресурсы: если
скорость записи в целевой кластер PostgreSQL недостаточна для
синхронизации изменений в реальном времени, то Synapse снижает скорость
чтения. Наибольшая производительность достигается в тех случаях, когда
данные на целевом кластере распределяются равномерно между узлами
(шардами).

## Конфигурация Synapse {: #configuration }

### Структура файла конфигурации {: #config_file }

Конфигурация Synapse хранится в YAML-файле и состоит из следующих основных блоков:

- настройки подключения к Oracle:
    - имя, хост и порт инстанса
    - настройки подключения к Xstream
    - настройки подключения к БД Oracle
- настройки подключения к кластеру PostgreSQL:
    - настройки подключения к каждому из шардов кластера
- соотношения таблиц между кластерами

<details><summary>Пример конфигурации с описанием полей</summary>

```yaml
runtime: # Настройки tokio-рантайма.
  name: "sistokio"
  worker_threads: 2

bridges:
  test: # Название моста, используется в логах.
    oracle:
      name: "test" # Название соединения, используется в логах.
      host: "localhost" # Адрес сервера, может быть dns или ip.
      port: 1521 # Порт.
      xstream_db: "TNT" # Название БД (service name), в которой создан xstream.
      xstream_name: "tntsync" # Название xstream.
      xstream_username: "c##xstrmadmin" # Имя пользователя, у которого есть права на подключение к xstream и захвату изменений из него.
      xstream_password: "xstrmadmin" # Пароль пользователя выше.
      init_db: "TNTPDB" # База данных, из которой необходимо забирать начальные данные.
      init_enabled: true # Включен или выключен модуль начального наполнения данных.
      init_username: "PDBADMIN" # Имя пользователя для чтения данных из базы.
      init_password: "tntPswd" # Пароль пользователя выше.
      connect_tries: 2 # Сколько попыток подключения делать перед тем, как инициализация плагина будет признана неуспешной.

    postgres:
      name: "test" # Название соединения, используется в логах.
      shards: # Если PostgreSQL не шардирован, укажите 1 шард ниже. Для успешной инициализации плагина необходимо подключение ко всем шардам.
        - host: "localhost" # Адрес шарда.
          port: 5431 # Port шарда.
          user: "postgres" # Имя пользователя для записи данных в шард.
          password: "tntPswd" # Пароль пользователя выше.
          db: "postgres" # Название БД, в которую пишутся данные.
          pool_size: 2 # Размер пул потоков.
          connect_tries: 2 # Сколько попыток подключения делать перед тем, как инициализация плагина будет признана неуспешной.

        - host: "localhost"
          port: 5433
          user: "postgres"
          password: "tntPswd"
          db: "postgres"
          pool_size: 2
          connect_tries: 2

    tables: # Настройка маппинга таблиц и колонок. Изменения в данных таблиц, не описанных ниже, будут проигнорированы.
      pdbadmin.deal: # Полное имя таблицы в Oracle.
        pk: ["id"] # Первичный ключ, может быть составным.
        name: "public.deal" # Полное имя таблицы в PostgreSQL.
        bindings: # Маппинг колонок в формате: <название колонки в Oracle> : [ "<название колонки в PostgreSQL>", "<тип данных в колонке>"" ].
          id: ["id", "int"]
          person_id: ["person_id", "int"]
          deal_number: ["deal_number", "text"]
          amount: ["amount", "decimal"]

      pdbadmin.person:
        pk: ["id"]
        name: "public.person"
        bindings:
          id: ["id", "int"]
          age: ["age", "int"]
          salary: ["salary", "decimal"]
          fullname: ["fullname", "text"]
```
</details>

Расположение файла конфигурации задается переменной `SYNAPSE_CONFIG`. Например:

```shell
$ echo $SYNAPSE_CONFIG
configs/config.cluster.yml
```

### Сопоставление колонок в таблицах {: #mapping }

Для корректного переноса данных требуется указать в файле конфигурации
сопоставление колонок для исходных и соответствующих им целевых таблиц. Для
конфигурации структуры данных воспользуйтесь таблицей ниже.

| Семейство типов значения в Oracle | Тип в PostgreSQL | Значение для файла конфигурации |
| ----------- | ------- | --------- |
| string | TEXT | text |
| binary | BYTE | byte |
| binary | BYTEA | bytea |
| number | INTEGER | int |
| number | BIGINT | bigint |
| number | SMALLINT | smallint |
| number | decimal | decimal |
| date | DATE | date |
| date | TIMESTAMP | timestamp |
| date | TIMESTAMPTZ | timestamptz |
| date with time | DATE | date |
| date with time | TIMESTAMP | timestamp |
| date with time | TIMESTAMPTZ | timestamptz |
| date with time and TZ | DATE | date |
| date with time and TZ | TIMESTAMP | timestamp |
| date with time and TZ | TIMESTAMPTZ | timestamptz |

Правила применения:

- XStream не присылает конкретный тип значения, только семейство типов
- В файле конфигурации следует указать значение (из третьей колонки
  таблицы выше), опираясь на семейство типов колонки в Oracle (первая
  колонка) и желаемый тип в PostgreSQL (вторая колонка)
- Если в конфигурации указаны `smallint`, `int`, `bigint`, то Synapse
  проверит, что число является целым и помещается в указанный тип
- При конвертации `date` -> `timestamp` Synapse выставит время в `00:00`
- При конвертации `date` -> `timestamptz` Synapse считает, что исходное
  значение в UTC. При этом, он сначала выставит время в `00:00`, затем
  сделает`timezoneoffset` в 0 секунд
- При конвертации `date with time` -> `timestamptz` Synapse считает, что
  исходное значение в UTC, и выставляет `timezoneoffset` в 0 секунд.
- При конвертации `date with time and TZ` -> `timestamp` Synapse
  конвертирует время в UTC
- При конвертации `date with time and TZ` -> `date` Synapse сначала
  конвертирует время в UTC, а потом берет от результата дату
- Значение `NULL` считается валидным для любой пары конвертации
- Любая другая пара (тип данных в Oracle, желаемый тип в PostgreSQL)
  приведет к ошибке и останову Synapse.

## Запуск Synapse {: #running }

Для запуска Synapse следует выполнить команду `picodata run` со скриптом, который инициализирует плагин:

```shell
picodata run --script=init.lua
```

Образец файла `init.lua` находится в [репозитории
Synapse](https://git.picodata.io/picodata/synapse/-/blob/master/init.lua).
