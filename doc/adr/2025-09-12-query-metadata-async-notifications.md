status: in progress

decision-makers: @kostja, @funbringer

---

# Отправка асинхронных уведомлений с метаданными запроса в pgproto для клиентов

## Мотивация

При получении SQL запроса, Пикодате необходимо вычислить `bucket_id` и
отправить запрос на нужный репликасет. Из-за лишних пересылок по сети
падает общая производительность системы.

Для увеличения производительности, необходимо добиться максимальной
локальности данных для запроса. Имея дополнительную метаинформацию
о запросе, клиент может отправить его сразу на репликасет, отвечающий
за хранение необходимой порции данных.

На стороне сервера, запросы от клиента сначала парсятся, затем
анализируются и переписываются. Результат (Prepared Statement)
записывается в специальный кэш.
При повторном получении запроса, сервер будет использовать Prepared Statement
из кэша. Такой алгоритм исключает повторный разбор запроса, при этом позволяет
выбрать наилучший план выполнения в зависимости от определённых значений
параметров.

Можно оптимизировать отправку запросов на конкретный инстанс Пикодаты.
Структура `Plan` в `Prepared Statement` имеет информацию о позициях 
параметров в запросе, которые отвечают за рассчет `bucket_id`. Мы можем
единоразово вычилить эту информацию и отправить её клиенту.

Такой подход имеет ряд преимуществ:

- **Снижение нагрузки**: вычисление bucket_id переносятся на клиента,
  происходят на стороне клиента, что снижает нагрузку на сервер и 
  убирает лишние пересылки по сети.
- **Умная обработка отказов**: в случае сбоя узла или изменения схемы таблицы, 
  клиент может повторно вычислить `bucket_id`.

## Продуктовые требования

Главным продуктовым требованием является поддержка "умных клиентов".
При получении определенного заголовка от клиента, сервер должен
предоставлять информацию для отправки запроса на нужный инстанс.

Больше информации можно узнать в этом [ADR](https://git.picodata.io/core/picodata/-/blob/master/doc/adr/2025-09-12-topology-change-async-notifications.md?ref_type=heads#%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D1%81%D0%BA%D0%B8%D0%B9-handshake).

## Реализация

### Обработка запросов в pgwire

В extended query mode протокол pgwire разделяет выполнение запроса на стадии:

- `Parse` — сервер разбирает SQL и создаёт Prepared Statement.
- `Bind` — сервер связывает параметры с этим Prepared Statement и создает Portal.
- `Execute` — сервер исполняет Portal.

На этапе `Parse` сервер либо возвращает ошибку, либо сообщение `ParseComplete`.
Именно на этом этапе необходимо отправлять
дополнительное `Notice`-сообщение перед `ParseComplete`. 

Так клиент получит сообщения в правильном порядке. Если для этого запроса 
еще нет записи в кэше клиента, то клиент отправит `Parse` запрос и получит 
Prepared Statement одновременно с [метаданными](#структура-preparedstatementmetadata).

Ниже представлена структура `Notice-сообщения`, содержащего метаинформацию
о запросе.

### Структура PreparedStatementMetadata

```rust
struct PreparedStatementMetadata {
   // Текст исходного SQL запроса,
   // необходимый для создания имени для 
   // PreparedStatement на клиенте.
   query: String,

   // Метаданные для запроса, cодержит информацию
   // про позиции ключей распределения в массиве
   // параметров запроса.
   dk_cols: Vec<u64>
}
```

### DDL invalidation

-  Возможна ситуация, когда версия схемы таблиц на сервере изменится. Например, 
   добавлением или изменением колонки. В таком слуае, все PreparedStatement, ссылающиеся
   на эту таблицу, потенциально, становятся невалидными. При попытке использовать PreparedStatement, 
   сервер должен сверить закешированные версии схемы таблиц в PreparedStatement c акутальными в Catalog.
   Если версии отличаются - сервер обязан отправить клиенту ошибку вида:
   
   ```c
   ERROR: prepared statement has been invalidated, reprepare (SQLSTATE: 42999)
   ```
   
   Получив такую ошибку, клиент должен выполнить reprepare - закрыть устаревший PreparedStatement и 
   отправить Parse-запрос повторно. 
   Для отправки такой ошибки необходимо расширить функционал `pgproto` определением нового типа и кода ошибки. 
   Со стороны клиента, нужно передать в заголовке (startup message) специальную kv-пару:

   ```go
   "picodata_stmtInvalidation" = true
   ```

   Это позволить не отправлять расширенный набор ошибок стандартным клиентам, так как они 
   их не ожидают. Также, такое разделение поможет включать каждую фичу отдельно, в зависимости
   от требовний клиента.

-  При установке соединения с сервером (инстансом), клиент обязан
   очистить кэш. Это один из шагов по восстановлению топологии, подробнее
   можно узнать [в этом ADR](https://git.picodata.io/core/picodata/-/blob/master/doc/adr/2025-09-12-topology-change-async-notifications.md?ref_type=heads#%D0%B2%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%BE%D0%BF%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8).


### Unbounded queries

Для ряда запросов Picodata **не может** однозначно вычислить `bucket_id`.
Если массив `dk_cols` в [PreparedStatementMetadata](#структура-preparedstatementmetadata)
не пустой - клиент может рассчитать для запроса bucket_id.
В ином случае, запрос отправляется на рандомный инстанс.

Ниже перечислены несколько частных случаев, при которых нельзя однозначно
определить `bucket_id`:

1. **DML/DQL без фильтрации по distributed by колонкам**
   Без условия по distributed by колонкам невозможно определить
   какие записи удалять/обновлять и на каких инстансах это делать.

   **Пример:**

   ```sql
   CREATE TABLE foo(a integer, b string, PRIMARY KEY (a)) USING MEMTX DISTRIBUTED BY (a);

   SELECT * from foo;
   UPDATE foo SET b = $1::string;
   ```

2. **DML/DQL c неполным набором distributed by колонок**  
   Без полного набора distributed by ключей нельзя вычислить `bucket_id`.

   **Пример:**

   ```sql
   CREATE TABLE foo(a integer, b integer, c double PRIMARY KEY (a)) USING MEMTX DISTRIBUTED BY (a,b);

   SELECT a,b from foo where a = $1::integer;
   ```

3. **Distributed JOIN**  
   Если соединение не является equi-join по ключу распределения таблиц
   или оно выполняется с глобальной таблицей, то такой JOIN становится
   распределённым. Cервер вынужден собирать данные с нескольких инстансов,
   и локальность теряется.

   **Пример:**

   ```sql
   CREATE TABLE foo(a integer, b string, PRIMARY KEY (a)) USING MEMTX DISTRIBUTED BY (a);
   CREATE TABLE bar(b integer, c double, PRIMARY KEY (b)) USING MEMTX DISTRIBUTED BY (b);

   SELECT foo.a, foo.b FROM foo JOIN bar ON foo.b = bar.b;
   ```

4. **Subquery**  
   Параметры используются для вычисления `bucket_id`.  
   Но значение некоторых неизвестно до выполнения подзапроса.

   **Пример:**

   ```sql
   CREATE TABLE foo(a integer, b string, PRIMARY KEY (a)) USING MEMTX DISTRIBUTED BY (a);
   CREATE TABLE bar(b integer, c double, PRIMARY KEY (b)) USING MEMTX DISTRIBUTED BY (b);

   INSERT INTO foo (a,b) VALUES ((SELECT cast(max(c) AS integer) FROM bar WHERE b > $1::integer), $2::string);
   SELECT a FROM foo WHERE a > (SELECT cast(max(c) AS integer) FROM bar WHERE b > $1::integer);
   ```

На стороне клиента, на уровне DEBUG, можно логироватьтакие SQL-запросы,
если не удалось применить оптимизацию. Такая логика поможет в случае
расследования низкой производительности запроса.

### Алгоритм вычисления bucket_id

Для вычисления `bucket_id` нужно получить список параметров, являющихся
ключами распределения. Вычисление происходит путем кодирования в 
бинарное представление и последующего хэширования результата по порядку
следования параметров в списке.

Так как мы используем протокол pgwire, после этапа Parse, объект
Prepared Statement будет хранить pgwire-типы для каждого переданного
параметра. Каждому такому типу соответствует его уникальный код (OID) и
текстовое название. Мы будем использовать их для правильного кодирования
этого параметра.

Алгоритм выглядит следующим образом:

1. Клиент получает список параметров для хэширования.
2. Инициализируется начальное состояние `MurmurHash`-объекта. 
3. В цикле, для каждого параметра в списке: 
   1. По соотвествию `OID -> тип` языка, определяется тип параметра.
   2. Значение параметра кодируется в бинарное представление `MessagePack`, согласно
      [некоторым правилам](#сериализация-параметров-messagepack). Рассмотрим их позже.
   3. Бинарное представление (массив байт) подается на вход функции хэширования. 
      Это действие изменяет состояние `MurmurHash`-объекта.
4. После хэширования всех параметров, вычисляется конечный хэш, 
   используя состояние `MurmurHash`-объекта. 
5. Конечный хэш делится по модулю на количество бакетов в кластере плюс один. 
6. Результат работы алгоритма - uint32 значение, которое является `bucket_id`. 

#### Хэширование параметров (Murmur)

С реализацией алгоритма можно ознакомиться в коде [tarantool-sys](https://git.picodata.io/core/tarantool/-/blob/2.11.5-picodata/third_party/PMurHash.c):

1. `PMurHash32_Process` отвечает за хэширование значений и мутацию внутр. состояния.
2. `PMurHash32_Result` отвечает за получение конечного хэша.

Или ознакомиться с исходным кодом одного из [умных драйверов](https://docs.picodata.io/picodata/stable/dev/connectors/).

##### Общие положения

Очевидно, что данные могут быть представлены как набор последовательных
байт. Для того, чтобы конвертировать произвольный набор байт в единое число,
можно использовать хэш-функции. В нашем случае, нам нужно получить
uint32 число (`bucket_id`) из списка параметров запроса.

Хэширование или хэш-функции позволяют обработать данные специальным образом.
Результатом работы такого алгоритма будет число фиксированной длины, которое
однозначно соответствует исходным данным.
Алгоритм может инциализироваться специальным значением - SEED. При одинаковом
SEED результат работы алгоритма тоже будет одинаковым. Таким образом, можно
получать одинаковые значения в разных средах исполнения (на сервере и клиенте).

Murmur - один из таких алгоритмов. Это быстрая, некриптографическая хеш-функция,
обеспечивает равномерное распределение значений. 

##### Алгоритм

Murmur обрабатывает входные данные порциями по 4 байта (32 бита). Каждый такой блок 
смешивается с внутренним состоянием через простые арифметические операции, создавая 
хорошо распределённое промежуточное значение. Если длина данных не делится на 4, 
последние 1–3 байта формируют неполный блок, который будет дообработан позже. 
Внутреннее состояние хранится между вызовами функции и называется `carry`.

`carry` — это 32-битное значение, в котором закодировано:

1. количество накопленных байт (n) — хранится в младшем байте.
2. содержимое этих байт (k1), уже упакованное в нужном порядке (little-endian) — 
   занимает старшие биты.

После обработки всех данных оставшиеся байты извлекаются из carry, домешиваются в 
хеш вместе с общей длиной сообщения, после чего выполняется финальный шаг, 
создающий равномерно распределённый 32-битный результат.

#### Сериализация параметров (MessagePack)

Tarantool оперирует данными, закодироваными в [Message Pack](https://github.com/msgpack/msgpack/blob/master/spec.md)(MP) формат. 
Перед хэшированием параметра, необходимо закодировать его значение в соответствующий вид.

На сайте [msgpack.org](https://msgpack.org/) представлены библиотеки для языков программирования. 
Так же, можно найти логику кодирования  для каждого типа в `tarantool-sys`: имена функций
придерживаются шаблона `mp_encode_*`, где * - имя типа данных.

В общем случае, значение кодируется как массив байт, состоящий из двух логических частей:

1. заголовок - деклариует тип и длину данных параметра
2. значение - хранит данные параметра

Обратим внимание, что Tarantool использует оптимизации хранения и кодирования данных. 
Нам нужно предерживаться их на клиенте, чтобы получить аналогичное представление. 
Рассмотрим алгоритмы кодирования для каждого типа данных в Picodata.

##### BOOLEAN

Стандарный алгоритм MessagePack.

##### DECIMAL

Бинарное представление Decimal:

```
                                           <------ payload data ----->
+--------+-------------------+------------+===============+===========+
| MP_EXT | length (optional) | MP_DECIMAL | scale         | BCD       |
| 1byte  |                   | 1byte      |               |           |
+--------+-------------------+------------+===============+===========+
                                           <------ length bytes ----->
```

Бинарное представление может отличаться, в зависимости от значения параметра.

1. Первый байт кодирует длину payload data. Если бинарное представление занимает 
   ровно 1/2/4/8/16 байт - будет использован `fixext 1/2/4/8/16`, поле `length` 
   отсутствовать. В других случаях, будет использоваться `ext 8/16/32` и поле `length` 
   хранить длину payload data. Байты для каждого имени формата можно найти в [документации](https://github.com/msgpack/msgpack/blob/master/spec.md#formats) MessagePack.
2. Следющий байт `0x01`, тип MP_DECIMAL.
3. scale - количество цифр после запятой. В зависимости от знака может быть int или uint.
   После определения нужного типа, кодируется по тем же правилам, что и тип [INTEGER](#integer).
4. BCD — это последовательность байтов, представляющих десятичные цифры закодированного числа. 
   Каждый байт состоит из двух десятичных цифр, каждая из которых закодирована с использованием 
   4-битных полубайтов: `байт >> 4` — первая цифра, а `байт & 0x0f` — вторая:
   
   ```
    value     BCD
   +---------+------------------+
   | 12.34   | 0x01, 0x23, 0x4c |
   |---------+------------------|
   | -12.345 | 0x12, 0x34, 0x5d |
   +---------+------------------+
   ```

   Первый полубайт хранит 0, если количество цифр в исходном числе четное.
   Последний полубайт последнего байта хранит `0x0D`, если исходное число отрицательное. Иначе `0x0C`.
   Крайняя левая цифра в массиве — старшая. Крайняя правая цифра в массиве — младшая.
5. При построении BCD, нужно убрать все старшие нули из представления. 
   Но оставить хотя бы один, если изначальное число равно 0. Они не влияют на числовое значение, 
   но занимают место и изменяют длину полезной нагрузки:

   ```
    value                    scale         BCD
   +------------------------+-------------+--------------+
   | 0.0000..10 (34 zeroes) |  36 (0x24)  |  0x01, 0x0c  |
   +------------------------+-------------+--------------+
   ```

Подробнее с форматом кодирования Decimal можно ознакомиться в [документации Tarantool](https://www.tarantool.io/en/doc/latest/reference/internals/msgpack_extensions/#the-decimal-type).
Код преобразования находится в [tarantool-sys/core/.../mp_decimal.c](https://git.picodata.io/core/tarantool/-/blob/2.11.5-picodata/src/lib/core/mp_decimal.c?ref_type=heads). Обратите внимание, что на вход функции подается `decimal_t*` - пользовательский тип. Его так же нужно перенести на сторону клиента.
Второй вариант - ознакомиться с исходным кодом одного из [умных драйверов](https://docs.picodata.io/picodata/stable/dev/connectors/).

##### DOUBLE (float32/float64)

Стандарный алгоритм MessagePack.

##### INTEGER

1. Если число ∊ `[0; INT64_MAX]` - оно будет представлено как uint.
2. Числа ∊ `[0; 127]` кодируются единственным байтом, без заголовка.
   Такие числа нужно обрабатывать отдельно:
3. Если значение умещается в `(u)int8/16/32/64` - оно будет 
   закодировано максимально компактным образом. Перед хэшированием
   нужно привести переменную к минимально подходящему типу:

   ```go
   var val int64 = 1337
   var norm_val = uint16(1337)
   ```

4. В остальных случаях, число кодируется стандартным алгоритмом MessagePack.

##### TEXT/STRING/VARCHAR

Для кодирования строк не нужно использовать алгоритм
из MessagePack. Они кодируются как последовательность байт
и в таком виде сразу передаются на вход функции хэширования.

Комментарий из кода `tarantool-sys`:

```c
/*
 * (!) MP_STR fields hashed **excluding** MsgPack format
 * indentifier. We have to do that to keep compatibility
 * with old third-party MsgPack (spec-old.md) implementations.
 * \sa https://github.com/tarantool/tarantool/issues/522
 */
```

##### UUID

Бинарное представление UUID:

```
+----------+------------+-----------------+
| MP_EXT   | MP_UUID    | UuidValue       |
| = 0xd8   | = 0x02     | = 16-byte value |
+----------+------------+-----------------+
```

1. Первый байт: `0xd8`, длина 16 байт.
2. Второй байт: `0x02`, тип MP_UUID.
3. 16-ти байтовое представление UUID.

##### DATETIME

Бинарное представление Datetime:

```
+-------------+----------------+=========+-----------------+
| MP_EXT      | MP_DATETIME    | seconds | nsec; tzoffset; |
| = 0xd7/0xd8 | = 0x04         | 8bytes  | tzindex; 8bytes |
+-------------+----------------+=========+-----------------+
```

1. Первый байт: длина закодированных данных:
   1. `0xd7` - 8 байт;
   2. `0xd8` - 16 байт;
2. Второй байт: `0x04`, тип MP_DATETIME.
3. Следующие 8 байт - секунды. Представлены как int64 Unix timestamp в порядке little-endian.
4. Следующие 8 байт опциональные. Включают nsec, tzoffset и tzindex, в порядке little-endian.
