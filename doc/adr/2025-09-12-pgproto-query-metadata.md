status: accepted

decision-makers: @kostja, @funbringer

---

# Отправка асинхронных уведомлений с метаданными запроса в pgproto для клиентов

## Используемые термины

* distribution key metadata / dist key meta / dk meta - параметры, формирующие ключ распределения, и их типы.
* parameter type metadata / param type meta / pt meta - параметры, участвующие в запросе, и их типы.

## Мотивация

При получении SQL запроса Пикодата вычисляет множество `bucket_id`,
определяет в соответствии с ним репликасеты и отправляет запрос на них. Это позволяет
клиенту не задумываться о выборе репликасета для выполнения запроса, а
делегировать это Пикодате. В случаях, когда необходима максимальная производительность,
определять нужный репликасет можно непосредственно в драйвере. Имея дополнительную
информацию о запросе, клиент сможет вычислить `bucket_id` и отправить запрос
сразу на репликасет, отвечающий за хранение соответствующей порции данных.

Такой подход имеет ряд преимуществ:

- **Снижение нагрузки**: вычисление `bucket_id` происходят на стороне клиента,
  что снижает нагрузку на сервер.
- **Умная обработка отказов**: в случае сбоя узла или изменения схемы таблицы
  клиент может повторно вычислить `bucket_id` и снова отправить запрос.

## Продуктовые требования

Главным продуктовым требованием является поддержка "умных клиентов".
При получении специального заголовка от клиента сервер должен
предоставлять информацию для отправки запроса на нужный репликасет.

Больше информации можно узнать в [этой](#клиентский-handshake) главе.

## Реализация

### Обработка запросов в pgwire

В режиме extended query протокол pgwire разделяет выполнение запроса на стадии:

- `Parse` — сервер разбирает SQL-запрос и создаёт Prepared Statement.
- `Bind` — сервер связывает параметры с этим Prepared Statement и создает Portal.
- `Execute` — сервер исполняет Portal.

На этапе `Parse` сервер либо возвращает ошибку, либо `Parse Complete` сообщение.
Именно на этом этапе необходимо отправлять дополнительное `Notice` сообщение
перед `Parse Complete`. 

Так клиент получит сообщения в правильном порядке: после отправки `Parse`
клиент получит [метаданные](#структура-preparedstatementmetadata). После 
остальных команд - `Prepared Statement`.

Ниже представлена структура `Notice`-сообщения, содержащего метаданные.

#### Структура PreparedStatementMetadata

```rust
struct PreparedStatementMetadata {
   // Текст исходного SQL запроса.
   // Необходим для создания имени 
   // Prepared Statement на клиенте.
   query: String,

   // Имя тира, в котором
   // лежат таблицы запроса.
   tier: String,

   // Метаданные SQL запроса.
   // Содержит индексы параметров, составляющих
   // ключ распределения, и идентификаторы типов
   // параметров(каждый тип параметра кодируется
   // числом Oid = u32).
   dk_meta: Vec<(u16, Oid)>
}
```

Поле `dk_meta` содержит массив кортежей, состоящих из индекса параметра и
идентификатора его типа. Параметр однозначно определяется своим индексом.

Рассмотрим следующий сценарий в psql:

```
CREATE TABLE t (a INT PRIMARY KEY, b DOUBLE);
INSERT INTO t VALUES ($1, $2) \bind 1 2 \g
```

Для второго запроса типы параметров $1 и $2 будут выведены из типов
колонок таблицы, куда происходит вставка. Так, параметр $1 будет иметь
тип int, а параметр $2 - double. Подробнее c вычислением parameter type
metadata можно ознакомиться в [АДР]
(https://git.picodata.io/core/picodata/-/blob/master/doc/adr/2025-05-27-type-system.md?ref_type=heads).

Вывод типов параметров необходим для поддержки postgres протокола. Во
время отправки сообщения `Bind` должны быть известны типы параметров,
т.к. они сериализуются в соответствии со своим типом и передаются в
бинарном формате. Из этого следует, что типы параметров должны вычисляться
на стадии `Parse` и не зависеть от самих переданных значений.


### Вычисление distribution key metadata

Алгоритм вычисления параметров, составляющих ключ распределения,
выглядит следующим образом:
- Вычисляем позиции колонок таблицы, формирующих ключ распределения.
- Каждой позиции ставим в соответствие переданный параметр и тип.

Результатом работы алгоритма является массив, содержащий индексы
параметров и типы. В случае, когда алгоритм не смог вычислить метадату,
возвращается пустой массив.

Исходный текст запроса и тир находятся в структурах `Parse` и `PreparedStatement`
соответственно.

### DDL invalidation

- Возможна ситуация, когда схема таблицы на сервере изменится из-за изменения
  состава колонок или удаления таблицы. В таком случае Prepared Statement,
  которые ссылаются на эту таблицу, становятся невалидными. При попытке использовать
  Prepared Statement сервер должен сверить закешированные версии схемы таблиц в
  Prepared Statement c актуальными в Catalog. Если отличаются  - сервер обязан
  отправить клиенту ошибку вида:

   ```c
   ERROR: prepared statement has been invalidated (SQLSTATE: 42999)
   ```

  После получения такой ошибки клиент выполняет reprepare - закрывает устаревший
  Prepared Statement и отправляет `Parse`-запрос повторно. Перед отправкой новой ошибки
  требуется расширить функциональность `pgproto` определением нового типа и кода ошибки.
- При установке соединения с сервером (инстансом) клиент обязан
  очистить кэш. Это один из шагов по восстановлению топологии, подробнее
  можно узнать [в этом ADR](https://git.picodata.io/core/picodata/-/blob/master/doc/adr/2025-09-12-pgproto-topology-notifications.md?ref_type=heads#%D0%B2%D0%BE%D1%81%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%BE%D0%BF%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8).

### Клиентский handshake

Для получения `Notice`-сообщений с метаданными запроса после этапа `Parse` клиент использует option или указывает в заголовке (startup message) специальную kv-пару:

```c
"pico_query_metadata" = true
```

Для получения нового типа ошибки при `Bind` невалидного `Prepared Statement` клиент использует option или указывает в заголовке (startup message) специальную kv-пару:

```c
"pico_stmt_invalidation" = true
```

Аналогичное поведение описано [в этом ADR](https://git.picodata.io/core/picodata/-/blob/master/doc/adr/2025-09-12-pgproto-topology-notifications.md?ref_type=heads#%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D1%81%D0%BA%D0%B8%D0%B9-handshake).

### Unbounded queries

Для ряда запросов Picodata **не может** однозначно вычислить `bucket_id`.
Под однозначностьюмы здесь понимаем то, что множество `bucket_id`,
вычисленных для запроса, содержит строго один `bucket_id`. Если массив
`dk_meta` в [PreparedStatementMetadata](#структура-preparedstatementmetadata)
не пустой - клиент может рассчитать для запроса bucket_id. В ином случае
запрос отправляется на случайный узел.

Ниже перечислены несколько частных случаев, при которых нельзя однозначно
определить `bucket_id`:

1. **DML/DQL без фильтрации по distributed by колонкам**
   Без условия по `distributed by` колонкам невозможно определить,
   какие записи удалять/обновлять и на каких узлах это делать.

   **Пример:**

   ```sql
   CREATE TABLE foo(a INT PRIMARY KEY, b TEXT) USING MEMTX DISTRIBUTED BY (a);

   SELECT * from foo;
   UPDATE foo SET b = $1::text;
   ```

2. **DML/DQL c неполным набором distributed by колонок**  
   Без полного набора distributed by колонок невозможно вычислить `bucket_id`.

   **Пример:**

   ```sql
   CREATE TABLE foo(a INT PRIMARY KEY, b INT, c DECIMAL) USING MEMTX DISTRIBUTED BY (a,b);

   SELECT a,b FROM foo WHERE a = $1::integer;
   ```
3. **DML/DQL, для которых выведено больше одного `bucket_id`**
   **Пример:**

   Для запроса ниже множество `bucket_id`, вычисленных Пикодатой, будет
   содержать два элемента, которые соответствуют параметрам $1 и $2.
   На данный момент мы ограничиваемся рассмотрением запросов, для которых
   таких неопределенностей не возникает, поэтому возвращаем пустую метадату.

   ```sql
   CREATE TABLE foo(a INT PRIMARY KEY, b INT) USING MEMTX DISTRIBUTED BY (b);

   SELECT a,b FROM foo WHERE b = $1 OR b = $2;
   ```

4. **Distributed JOIN**
   Если соединение не является equi-join по ключу распределения таблиц
   или оно выполняется с глобальной таблицей, то такой JOIN становится
   распределённым. Сервер вынужден собирать данные с нескольких инстансов,
   и локальность теряется.

   **Пример:**

   ```sql
   CREATE TABLE foo(a INT PRIMARY KEY, b TEXT) USING MEMTX DISTRIBUTED BY (a);
   CREATE TABLE bar(b TEXT PRIMARY KEY, c DOUBLE) USING MEMTX DISTRIBUTED BY (b);

   SELECT foo.a, foo.b FROM foo JOIN bar ON foo.b = bar.b;
   ```

5. **Subquery**
   Параметры используются для вычисления `bucket_id`.  
   Но значения некоторых неизвестны до выполнения подзапроса.

   **Пример:**

   ```sql
   CREATE TABLE foo(a INT PRIMARY KEY, b TEXT) USING MEMTX DISTRIBUTED BY (a);
   CREATE TABLE bar(b INT PRIMARY KEY, c double) USING MEMTX DISTRIBUTED BY (b);

   INSERT INTO foo (a,b) VALUES ((SELECT cast(max(c) AS INT) FROM bar WHERE b > $1::integer), $2::text);
   SELECT a FROM foo WHERE a > (SELECT cast(max(c) AS INT) FROM bar WHERE b > $1::integer);
   ```

На стороне клиента можно логировать SQL-запросы,
для которых не удалось применить оптимизацию. Такая логика поможет
расследовать низкую производительность запроса.

### Алгоритм вычисления bucket_id

Для вычисления `bucket_id` нужно получить список параметров, являющихся
ключами распределения, и их типы. Вычисление происходит путем кодирования в 
бинарное представление и последующего хеширования результата по порядку
следования параметров в списке.

Алгоритм выглядит следующим образом:

1. Клиент получает список параметров и идентификаторов типов (OID) для хеширования.
2. Инициализируется начальное состояние `MurmurHash`-объекта SEED равным `13 (uint32)`.
3. В цикле для каждого параметра в списке:
   1. По соответствию `OID -> тип`, определяется тип параметра.
   2. Значение параметра кодируется в бинарное представление `MessagePack`, согласно
      [некоторым правилам](#сериализация-параметров-messagepack).
   3. Бинарное представление (массив байт) подается на вход функции хеширования.
4. После хеширования всех параметров вычисляется конечный хэш.
5. Конечный хэш делится по модулю на количество бакетов в кластере плюс один. 
6. Результатом работы алгоритма является `bucket_id` - uint32 значение. 

#### Хеширование параметров (MurmurHash)

Чтобы преобразовать закодированные параметры в единое число (`bucket_id`),
используется алгоритм [MurmurHash](https://en.wikipedia.org/wiki/MurmurHash).

С реализацией алгоритма можно ознакомиться в коде [tarantool-sys](https://git.picodata.io/core/tarantool/-/blob/2.11.5-picodata/third_party/PMurHash.c):

1. `PMurHash32_Process` отвечает за хеширование значений.
2. `PMurHash32_Result` отвечает за получение конечного хеша.

Или ознакомиться с исходным кодом одного из [умных драйверов](https://docs.picodata.io/picodata/stable/dev/connectors_index/).

#### Сериализация параметров (MessagePack)

Tarantool оперирует данными, закодированными в [Message Pack](https://github.com/msgpack/msgpack/blob/master/spec.md)(MP) формат. 
Перед хешированием параметра необходимо закодировать его значение в соответствующий вид.

На сайте [msgpack.org](https://msgpack.org/) представлены библиотеки для языков программирования. 
Также можно найти логику кодирования  для каждого типа в [tarantool-sys](https://git.picodata.io/core/tarantool/): имена функций
придерживаются шаблона `mp_encode_*`, где `*` - название типа данных.

В общем случае значение кодируется как массив байт, состоящий из двух логических частей:

1. заголовок - декларирует тип и длину данных параметра
2. значение - хранит данные параметра

Обратим внимание, что Tarantool использует оптимизации хранения и кодирования данных. 
Нам нужно придерживаться их на клиенте, чтобы получить аналогичное представление. 
Рассмотрим алгоритмы кодирования для каждого типа данных в Picodata.

##### BOOLEAN

Стандартный алгоритм MessagePack.

##### DECIMAL

Бинарное представление Decimal:

```
                                           <------ payload data ----->
+--------+-------------------+------------+===============+===========+
| MP_EXT | length (optional) | MP_DECIMAL | scale         | BCD       |
| 1byte  |                   | 1byte      |               |           |
+--------+-------------------+------------+===============+===========+
                                           <------ length bytes ----->
```

Бинарное представление может отличаться в зависимости от значения параметра.

1. Первый байт кодирует длину payload data. Если бинарное представление занимает 
   ровно 1/2/4/8/16 байт - будет использован `fixext 1/2/4/8/16`, поле `length` 
   отсутствовать. В других случаях будет использоваться `ext 8/16/32` и поле `length`
   хранить длину payload data. Байты для каждого имени формата можно найти в [документации](https://github.com/msgpack/msgpack/blob/master/spec.md#formats) MessagePack.
2. Следующий байт `0x01`, тип MP_DECIMAL.
3. scale - количество цифр после запятой. В зависимости от знака может быть int или uint.
   После определения нужного типа кодируется по тем же правилам, что и тип [INTEGER](#integer).
4. BCD — это последовательность байтов, представляющих десятичные цифры закодированного числа. 
   Каждый байт состоит из двух десятичных цифр, каждая из которых закодирована с использованием 
   4-битных полубайтов: `байт >> 4` — первая цифра, а `байт & 0x0f` — вторая:
   
   ```
    value     BCD
   +---------+------------------+
   | 12.34   | 0x01, 0x23, 0x4c |
   |---------+------------------|
   | -12.345 | 0x12, 0x34, 0x5d |
   +---------+------------------+
   ```

   Первый полубайт хранит 0, если количество цифр в исходном числе четное.
   Последний полубайт последнего байта хранит `0x0D`, если исходное число отрицательное. Иначе `0x0C`.
   Крайняя левая цифра в массиве — старшая. Крайняя правая цифра в массиве — младшая.
5. При построении BCD, нужно убрать все старшие нули из представления. 
   Но оставить хотя бы один, если изначальное число равно 0. Они не влияют на числовое значение, 
   но занимают место и изменяют длину полезной нагрузки:

   ```
    value                    scale         BCD
   +------------------------+-------------+--------------+
   | 0.0000..10 (34 zeroes) |  36 (0x24)  |  0x01, 0x0c  |
   +------------------------+-------------+--------------+
   ```

Подробнее с форматом кодирования Decimal можно ознакомиться в [документации Tarantool](https://www.tarantool.io/en/doc/latest/reference/internals/msgpack_extensions/#the-decimal-type).
Код преобразования находится в [tarantool-sys/core/.../mp_decimal.c](https://git.picodata.io/core/tarantool/-/blob/2.11.5-picodata/src/lib/core/mp_decimal.c?ref_type=heads). Обратите внимание, что на вход функции подается `decimal_t*` - пользовательский тип. Его так же нужно перенести на сторону клиента.
Второй вариант - ознакомиться с исходным кодом одного из [умных драйверов](https://docs.picodata.io/picodata/stable/dev/connectors_index/).

##### DOUBLE (float32/float64)

Стандартный алгоритм MessagePack.

##### INTEGER

1. Если число ∊ `[0; INT64_MAX]` - оно будет представлено как uint.
2. Числа ∊ `[0; 127]` кодируются единственным байтом, без заголовка.
   Такие числа нужно обрабатывать отдельно:
3. Если значение умещается в `(u)int8/16/32/64` - оно будет 
   закодировано максимально компактным образом. Перед хешированием
   нужно привести переменную к минимально подходящему типу:

   ```go
   var val int64 = 1337
   var norm_val = uint16(1337)
   ```

4. В остальных случаях число кодируется стандартным алгоритмом MessagePack.

##### TEXT/STRING/VARCHAR

Для кодирования строк не нужно использовать алгоритм
из MessagePack. Они кодируются как последовательность байт
и в таком виде сразу передаются на вход функции хеширования.

Комментарий из кода `tarantool-sys`:

```c
/*
 * (!) MP_STR fields hashed **excluding** MsgPack format
 * indentifier. We have to do that to keep compatibility
 * with old third-party MsgPack (spec-old.md) implementations.
 * \sa https://github.com/tarantool/tarantool/issues/522
 */
```

##### UUID

Бинарное представление UUID:

```
+----------+------------+-----------------+
| MP_EXT   | MP_UUID    | UuidValue       |
| = 0xd8   | = 0x02     | = 16-byte value |
+----------+------------+-----------------+
```

1. Первый байт: `0xd8`, длина 16 байт.
2. Второй байт: `0x02`, тип MP_UUID.
3. 16-ти байтовое представление UUID.

##### DATETIME

Бинарное представление Datetime:

```
+-------------+----------------+=========+-----------------+
| MP_EXT      | MP_DATETIME    | seconds | nsec; tzoffset; |
| = 0xd7/0xd8 | = 0x04         | 8bytes  | tzindex; 8bytes |
+-------------+----------------+=========+-----------------+
```

1. Первый байт: длина закодированных данных:
   1. `0xd7` - 8 байт;
   2. `0xd8` - 16 байт;
2. Второй байт: `0x04`, тип MP_DATETIME.
3. Следующие 8 байт - секунды. Представлены как int64 Unix timestamp в порядке little-endian.
4. Следующие 8 байт опциональные. Включают nsec, tzoffset и tzindex, в порядке little-endian.
